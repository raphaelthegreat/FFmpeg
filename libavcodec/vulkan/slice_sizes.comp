#version 450 core
#extension GL_EXT_shader_explicit_arithmetic_types : require

#define SLICE_WIDTH 32
#define SLICE_HEIGHT 16

layout(local_size_x = SLICE_WIDTH, local_size_y = SLICE_HEIGHT, local_size_z = 1) in;

#define DIRAC_MAX_QUANT_INDEX 116
#define MAX_DWT_LEVELS 5

struct SliceArgs {
    int cache[DIRAC_MAX_QUANT_INDEX];
    int x;
    int y;
    int quant_idx;
    int bits_ceil;
    int bits_floor;
    int bytes;
};

layout(std430, buffer_reference) buffer SliceArgBuf {
    SliceArgs args[];
};

layout(push_constant, std140) uniform ComputeInfo {
    int wavelet_depth;
    ivec2 slice_dim;
    int quant_idx;
    int size_scaler;
    int prefix_bytes;
    ivec2 num_slices;
    DwtCoef p[3];
    BitBuf pb;
    SliceArgBuf slices;
};

int count_vc2_ue_uint(int val) {
    int topbit = 1, maxval = 1;
    if (!val++)
        return 1;
    while (val > maxval) {
        topbit <<= 1;
        maxval <<= 1;
        maxval |=  1;
    }
    return log2(topbit)*2 + 1;
}

int ffalign(int x, int a) {
    return (x + a - 1) & ~(a - 1);
}

int get_level() {
    ivec2 slice_coord = ivec2(gl_LocalInvocationID.xy);
    ivec2 image_dim = ivec2(SLICE_WIDTH, SLICE_HEIGHT) * num_slices;
    #pragma unroll
    for (int level = 0; level < 5; level++) {
        /* wavelet_depth = how many times to divide by 2 to get band width of level 0 */
        int div = 2 * (wavelet_depth - level);
        if (all(lessThan(slice_coord, image_dim / div))) {
            return level;
        }
    }
}

int count_hq_slice(int quant_idx) {
    shared int bits = 0;
    const int slice_idx = gl_WorkGroupID.y * gl_NumWorkgroups.x + gl_WorkGroupID.x;

    SliceArgs slice = slices.args[slice_idx];
    if (slice.cache[quant_idx])
        return slice.cache[quant_idx];

    /* Initialize bits array */
    bits = 8 * (prefix_bytes + 1);

    const int level = get_level();
    const int b_width = SLICE_WIDTH >> level;
    const int b_height = SLICE_HEIGHT >> level;
    const int s_x = gl_WorkGroupID.x;
    const int s_y = gl_WorkGroupID.y;

    const int q_idx = quant[level][orientation];
    const int q_s = av_log2(ff_dirac_qscale_tab[q_idx]) + 32;

    for (int p = 0; p < 3; p++) {
        /* This is executed once for each plane */
        if (gl_LocalInvocationIndex == 0) {
            atomicAdd(bits, 8);
        }
        barrier();

        /* Perform quantization and calculate size with exp-Golomb coding */
        const int c_abs = (abs(buf[x] / q_idx) >> q_s;
        atomicAdd(bits, count_vc2_ue_uint(c_abs) + int(c_abs != 0));

        /* This is executed once for each plane */
        if (gl_LocalInvocationIndex == 0) {
            atomicAdd(bits, ffalign(bits, 8) - bits);
            const int bytes_len = (bits >> 3) - 1;
            const int pad_s = ffalign(bytes_len, size_scaler) / size_scaler;
            const int pad_c = (pad_s * size_scaler) - bytes_len;
            atomicAdd(bits, pad_c * 8);
        }
        barrier();
    }

    slices.args[slice_idx].cache[quant_idx] = bits;
    return bits;
}

int av_rescale(int a, int b, int c) {
    // TODO: This won't overflow, right?
    const int r = c / 2;
    return (a * b + r) / c;
}

int ssize_round(int b, int size_scaler, int prefix_bytes) {
    return ffalign(b, size_scaler) + 4 + prefix_bytes;
}

void main() {
    /* Use the first invocation of the workgroup to compute the min/max slice sizes. */
    shared int bits_ceil = 0;
    shared int bits_floor = 0;
    if (gl_LocalInvocationIndex == 0) {
        const bool bitexact = true;
        const int aux_data_size = bitexact ? 5 : 13;
        const int header_size = 100 + aux_data_size;
        const int bit_rate = 600000000;
        const int interlaced = 0;
        const int time_base_num = 1;
        const int time_base_den = 30;
        const int r_bitrate = bit_rate >> interlaced;

        const int frame_max_bytes = (av_rescale(r_bitrate, time_base_num, time_base_den) >> 3) - header_size;
        const int slice_ceil = av_rescale(frame_max_bytes, 1, gl_NumWorkgroups.x * gl_NumWorkgroups.y);
        int slice_max_bytes = slice_ceil;

        /* Find an appropriate size scaler */
        int size_scaler = 2;
        int sig_size = 256;
        while (sig_size > 255) {
            int r_size = ssize_round(slice_max_bytes, size_scaler, prefix_bytes);
            if (r_size > slice_ceil) {
                slice_max_bytes -= r_size - slice_ceil;
                r_size = ssize_round(slice_max_bytes, size_scaler, prefix_bytes);
            }
            sig_size = r_size / size_scaler; /* Signalled slize size */
            size_scaler <<= 1;
        }

        const float tolerance = 5.f;
        const int slice_min_bytes = slice_max_bytes - slice_max_bytes*(tolerance/100.0f);
        bits_ceil = slice_max_bytes << 3;
        bits_floor = slice_min_bytes << 3;
    }
    barrier();

    /* Calculate the size of the slice */
    const int q_ceil = DIRAC_MAX_QUANT_INDEX;
    const int top = bits_ceil;
    const int bottom = bits_floor;
    int quant_buf[2] = int[2](-1, -1);
    int quant = quant_idx;
    int step = 1;
    int bits_last = 0;
    int bits = count_hq_slice(quant);
    while ((bits > top) || (bits < bottom)) {
        const int signed_step = bits > top ? +step : -step;
        quant  = clamp(quant + signed_step, 0, q_ceil-1);
        bits = count_hq_slice(quant);
        if (quant_buf[1] == quant) {
            quant = max(quant_buf[0], quant);
            bits  = quant == quant_buf[0] ? bits_last : bits;
            break;
        }
        step         = av_clip(step/2, 1, (q_ceil-1)/2);
        quant_buf[1] = quant_buf[0];
        quant_buf[0] = quant;
        bits_last    = bits;
    }
    slice_dat->quant_idx = av_clip(quant, 0, q_ceil-1);
    slice_dat->bytes = SSIZE_ROUND(bits >> 3);
}