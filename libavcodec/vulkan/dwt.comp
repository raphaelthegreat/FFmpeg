#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 3) in;

layout(std430, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {
    uint coef_buf[];
};

layout(push_constant, scalar) uniform ComputeInfo {
    int wavelet_depth;
    int s;
    DwtCoef p[3];
};

void main() {
    #pragma unroll
    int stride = imageSize(planes[0]).x;
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    for (int l = 0; l < wavelet_depth - 1; l++) {
        const uint plane_idx = gl_LocalInvocationID.z;
        /* dst_size is twice the level subband size and represents our work area */
        ivec2 dst_size = imageSize(planes[plane_idx]) >> l;
        ivec2 synth_size = dst_size >> 1;
        if (any(greaterThan(coord, dst_size))) {
            break;
        }

        /* For horizontal synth pass, each invocation handles a horizontal pair of pixels */
        ivec2 coord_x = coord << ivec2(1, 0);
        if (all(lessThan(coord_x, synth_size))) {
            uint a = uint(imageLoad(planes[plane_idx], coord_x).x * 255.0);
            uint b = uint(imageLoad(planes[plane_idx], coord_x + ivec2(1, 0)).x * 255.0);
            uint dst_b = (b - a) * (1 << s);
            uint dst_a = a * (1 << s) + ((dst_b + 1) >> 1);
            p[plane_idx].coef_buf[coord_x.y * stride + coord_x.x] = dst_a;
            p[plane_idx].coef_buf[coord_x.y * stride + coord_x.x + 1] = dst_b;
        }
        memoryBarrier();

        /* For vertical synth pass, each invocation handles a vertical pair of pixels */
        ivec2 coord_y = coord << ivec2(0, 1);
        if (all(lessThan(coord_y, synth_size))) {
            uint a = uint(imageLoad(planes[plane_idx], coord_y).x * 255.0);
            uint b = uint(imageLoad(planes[plane_idx], coord_y + ivec2(0, 1)).x * 255.0);
            uint dst_b = b - a;
            uint dst_a = a + ((dst_b + 1) >> 1);
            p[plane_idx].coef_buf[coord_y.y * stride + coord_y.x] = dst_a;
            p[plane_idx].coef_buf[(coord_y.y + 1) * stride + coord_y.x + 1] = dst_b;
        }
        memoryBarrier();

        /* Finally deinterleave result. Here each invocation is responsible for a single pixel */
        ivec2 subband = coord & int(1);
        ivec2 new_coord = subband * synth_size + (coord >> 1);
        uint texel = p[plane_idx].coef_buf[coord.y * stride + coord.x];
        barrier();
        p[plane_idx].coef_buf[new_coord.y * stride + new_coord.x] = texel;
    }
}
