#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_debug_printf : require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(scalar, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {
    int coef_buf[];
};

struct Plane {
    ivec2 dim;
    int coef_stride;
    int pad;
};

#define VC2_TRANSFORM_HAAR (3)
#define VC2_TRANSFORM_HAAR_S (4)
#define VC2_TRANSFORM_5_3 (1)

layout(push_constant, scalar) uniform ComputeInfo {
    int s;
    int diff_offset;
    int level;
    int wavelet_type;
    Plane planes[3];
    DwtCoef dst_buf[3];
    DwtCoef src_buf[3];
};

void main() {
    int coord_y = int(gl_GlobalInvocationID.x);
    uint plane_idx = gl_GlobalInvocationID.z;
    ivec2 work_area = planes[plane_idx].dim >> level;
    if (coord_y >= work_area.y) {
        return;
    }

    DwtCoef src = src_buf[plane_idx];
    DwtCoef dst = dst_buf[plane_idx];
    ivec2 dwt_area = work_area >> 1;
    int start = planes[plane_idx].coef_stride * coord_y;
    
    // Shift in one bit that is used for additional precision
    for (int x = 0; x < work_area.y; x++) {
        dst.coef_buf[start + x] = src.coef_buf[start + x] << 1;
    }

    // Lifting stage 2
    for (int x = 0; x < dwt_area.x - 1; x++) {
        dst.coef_buf[start + 2 * x + 1] -= (dst.coef_buf[start + 2 * x] +
                                            dst.coef_buf[start + 2 * x + 2] + 1) >> 1;
    }
    dst.coef_buf[start + work_area.x - 1] -= (2 * dst.coef_buf[start + work_area.x - 2] + 1) >> 1;

    // Lifting stage 1
    dst.coef_buf[start] += (2 * dst.coef_buf[start + 1] + 2) >> 2;
    for (int x = 1; x < dwt_area.x - 1; x++) {
        dst.coef_buf[start + 2 * x] += (dst.coef_buf[start + 2 * x - 1] +
                                        dst.coef_buf[start + 2 * x + 1] + 2) >> 2;
    }
    dst.coef_buf[start + work_area.x - 2] += (dst.coef_buf[start + work_area.x - 3] +
                                              dst.coef_buf[start + work_area.x - 1] + 2) >> 2;
}
