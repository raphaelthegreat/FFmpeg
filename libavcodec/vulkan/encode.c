// Generated from libavcodec/vulkan/encode.comp
const char *ff_source_encode_comp =
"#version 450 core\n"
"#extension GL_EXT_buffer_reference : require\n"
"#extension GL_EXT_shader_explicit_arithmetic_types : require\n"
"\n"
"// TODO: Process pixels in parallel\n"
"layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n"
"\n"
"#define MAX_DWT_LEVELS (5)\n"
"\n"
"layout(std430, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {\n"
"    int coef_buf[];\n"
"};\n"
"layout(std430, buffer_reference, buffer_reference_align = 1) buffer BitBuf {\n"
"    uint8_t data[];\n"
"};\n"
"\n"
"layout(push_constant, std140) uniform ComputeInfo {\n"
"    int wavelet_depth;\n"
"    ivec2 slice_dim;\n"
"    int quant_idx;\n"
"    int size_scaler;\n"
"    int prefix_bytes;\n"
"    ivec2 num_slices;\n"
"    DwtCoef p[3];\n"
"    BitBuf pb;\n"
"};\n"
"\n"
"int encode_subband(ivec2 slice_coord, ivec2 band_size, int quant, int o, int plane, int write_index) {\n"
"    int left = band_size.x * (slice_coord.x+0) / num_slices.x;\n"
"    int right = band_size.x * (slice_coord.x+1) / num_slices.x;\n"
"    int top = band_size.y * (slice_coord.y+0) / num_slices.y;\n"
"    int bottom = band_size.y * (slice_coord.y+1) / num_slices.y;\n"
"\n"
"    int stride = slice_dim.x * num_slices.x;\n"
"    int band_ptr = int(o > 1) * band_size.y * stride + (o & 1) * band_size.x;\n"
"    int start = band_ptr + top * stride;\n"
"    const int q_s = int(log2(ff_dirac_qscale_tab[quant])) + 32;\n"
"\n"
"    for (int y = top; y < bottom; y++) {\n"
"        for (int x = left; x < right; x++) {\n"
"            int coef = p[plane].coef_buf[band_ptr + x];\n"
"            uint c_abs = uint((abs(coef) / quant) >> q_s);\n"
"            for (int i = 0; i < 4; i++) {\n"
"                pb.data[write_index++] = uint8_t((c_abs >> (i * 8)) & 0xFF);\n"
"            }\n"
"            //if (c_abs != 0)\n"
"            //    put_bits(pb, 1, coef < 0);\n"
"        }\n"
"        band_ptr += stride;\n"
"    }\n"
"\n"
"    return write_index;\n"
"}\n"
"\n"
"int align(int x, int a) {\n"
"    return (x+a-1) & ~(a-1);\n"
"}\n"
"\n"
"void encode_hq_slice(int slice_bytes_max) {\n"
"    ivec2 slice_coord = ivec2(gl_GlobalInvocationID.xy);\n"
"    int slice_index = slice_coord.y * slice_dim.x + slice_coord.x;\n"
"    int write_ptr = slice_bytes_max * slice_index;\n"
"    int bit_ptr = 0;\n"
"\n"
"    /* The reference decoder ignores it, and its typical length is 0 */\n"
"    for (int i = 0; i < prefix_bytes; i++) {\n"
"        pb.data[write_ptr + i] = uint8_t(0);\n"
"    }\n"
"    write_ptr += prefix_bytes;\n"
"\n"
"    /* Write quant index for this slice */\n"
"    for (int i = 0; i < 4; i++) {\n"
"        pb.data[write_ptr++] = uint8_t((quant_idx >> (i * 8)) & 0xFF);\n"
"    }\n"
"    //pb.data[write_ptr++] = quant_idx;\n"
"\n"
"    /* Luma + 2 Chroma planes */\n"
"    #pragma unroll\n"
"    for (int p = 0; p < 3; p++) {\n"
"        int pad_s, pad_c;\n"
"        int bytes_start = write_ptr;\n"
"        pb.data[write_ptr++] = uint8_t(0);\n"
"        #pragma unroll\n"
"        for (int level = 0; level < wavelet_depth; level++) {\n"
"            ivec2 band_size = slice_dim >> level;\n"
"            #pragma unroll\n"
"            for (int orientation = int(level > 0); orientation < 4; orientation++) {\n"
"                write_ptr = encode_subband(slice_coord, band_size, quant[level][orientation],\n"
"                                           orientation, p, write_ptr);\n"
"            }\n"
"        }\n"
"        //flush_put_bits(pb);\n"
"        int bytes_len = /*put_bytes_output(pb)*/write_ptr - bytes_start - 1;\n"
"        if (p == 2) {\n"
"            int len_diff = slice_bytes_max - /*put_bytes_output(pb)*/write_ptr;\n"
"            pad_s = align((bytes_len + len_diff), size_scaler)/size_scaler;\n"
"            pad_c = (pad_s*size_scaler) - bytes_len;\n"
"        } else {\n"
"            pad_s = align(bytes_len, size_scaler)/size_scaler;\n"
"            pad_c = (pad_s*size_scaler) - bytes_len;\n"
"        }\n"
"        pb.data[bytes_start] = uint8_t(pad_s);\n"
"        /* vc2-reference uses that padding that decodes to '0' coeffs */\n"
"        for (int i = 0; i < pad_c; i++) {\n"
"            pb.data[write_ptr++] = uint8_t(0xFF);\n"
"        }\n"
"        // memset(put_bits_ptr(pb), 0xFF, pad_c);\n"
"        // skip_put_bytes(pb, pad_c);\n"
"    }\n"
"}\n"
"\n"
"void main() {\n"
"    /* Step 1. TODO: Figure out appropriate quant index for optimal slice size */\n"
"    int slice_bytes_max = (1280 * 720 * 3 / 2) / (num_slices.x * num_slices.y);\n"
"\n"
"    /* Step 2. Quantize and encode */\n"
"    encode_hq_slice(slice_bytes_max);\n"
"}\n";
