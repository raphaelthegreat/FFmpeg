// Generated from libavcodec/vulkan/encode.comp
const char *ff_source_encode_comp =
"#extension GL_EXT_shader_explicit_arithmetic_types : require\n"
"\n"
"// TODO: Process pixels in parallel\n"
"layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n"
"\n"
"#define MAX_DWT_LEVELS (5)\n"
"\n"
"layout(std430, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {\n"
"    int coef_buf[];\n"
"};\n"
"layout(std430, buffer_reference, buffer_reference_align = 1) buffer BitBuf {\n"
"    uint data[];\n"
"};\n"
"layout(std430, buffer_reference, buffer_reference_align = 4) buffer QuantLuts {\n"
"    int quant[5][4];\n"
"    int ff_dirac_qscale_tab[116];\n"
"};\n"
"\n"
"layout(push_constant, std430) uniform ComputeInfo {\n"
"    DwtCoef p[4];\n"
"    BitBuf pb;\n"
"    QuantLuts luts;\n"
"    ivec2 num_slices;\n"
"    ivec2 slice_dim;\n"
"    int wavelet_depth;\n"
"    int quant_idx;\n"
"    int size_scaler;\n"
"    int prefix_bytes;\n"
"};\n"
"\n"
"uint bit_buf = 0;\n"
"uint bit_left = 32;\n"
"int write_ptr = 0;\n"
"\n"
"void put_bits(int n, int value) {\n"
"    if (n < bit_left) {\n"
"        bit_buf = (bit_buf << n) | value;\n"
"        bit_left -= n;\n"
"    } else {\n"
"        bit_buf <<= bit_left;\n"
"        bit_buf |= value >> (n - bit_left);\n"
"        pb.data[write_ptr++] = bit_buf;\n"
"        bit_left += 32 - n;\n"
"        bit_buf = value;\n"
"    }\n"
"}\n"
"\n"
"void put_vc2_ue_uint(int val) {\n"
"    int pbits = 0, topbit = 1, maxval = 1;\n"
"    if (val++ == 0) {\n"
"        put_bits(1, 1);\n"
"        return;\n"
"    }\n"
"\n"
"    while (val > maxval) {\n"
"        topbit <<= 1;\n"
"        maxval <<= 1;\n"
"        maxval |=  1;\n"
"    }\n"
"\n"
"    int bits = int(log2(topbit));\n"
"    for (int i = 0; i < bits; i++) {\n"
"        topbit >>= 1;\n"
"        pbits <<= 2;\n"
"        if ((val & topbit) != 0) {\n"
"            pbits |= 0x1;\n"
"        }\n"
"    }\n"
"\n"
"    put_bits(bits * 2 + 1, (pbits << 1) | 1);\n"
"}\n"
"\n"
"void flush_put_bits() {\n"
"    pb.data[write_ptr++] = bit_buf;\n"
"    bit_buf = 0;\n"
"}\n"
"\n"
"int put_bytes_output() {\n"
"    return write_ptr * 4;\n"
"}\n"
"\n"
"void skip_put_bytes(int n) {\n"
"    write_ptr += (n >> 2);\n"
"    bit_left = (n % 4) * 8;\n"
"}\n"
"\n"
"void encode_subband(ivec2 slice_coord, ivec2 band_size, int quant, int o, int plane) {\n"
"    int left = band_size.x * (slice_coord.x+0) / num_slices.x;\n"
"    int right = band_size.x * (slice_coord.x+1) / num_slices.x;\n"
"    int top = band_size.y * (slice_coord.y+0) / num_slices.y;\n"
"    int bottom = band_size.y * (slice_coord.y+1) / num_slices.y;\n"
"\n"
"    int stride = slice_dim.x * num_slices.x;\n"
"    int band_ptr = int(o > 1) * band_size.y * stride + (o & 1) * band_size.x;\n"
"    int start = band_ptr + top * stride;\n"
"    const int q_s = int(log2(luts.ff_dirac_qscale_tab[quant])) + 32;\n"
"\n"
"    for (int y = top; y < bottom; y++) {\n"
"        for (int x = left; x < right; x++) {\n"
"            int coef = p[plane].coef_buf[band_ptr + x];\n"
"            int c_abs = int((abs(coef) / quant) >> q_s);\n"
"            put_vc2_ue_uint(c_abs);\n"
"            if (c_abs != 0)\n"
"                put_bits(1, int(coef < 0));\n"
"        }\n"
"        band_ptr += stride;\n"
"    }\n"
"}\n"
"\n"
"int align(int x, int a) {\n"
"    return (x+a-1) & ~(a-1);\n"
"}\n"
"\n"
"void encode_hq_slice(int slice_bytes_max) {\n"
"    ivec2 slice_coord = ivec2(gl_GlobalInvocationID.xy);\n"
"    int slice_index = slice_coord.y * slice_dim.x + slice_coord.x;\n"
"    write_ptr = slice_bytes_max * slice_index;\n"
"\n"
"    /* Write quant index for this slice */\n"
"    put_bits(8, quant_idx);\n"
"\n"
"    /* Luma + 2 Chroma planes */\n"
"    #pragma unroll\n"
"    for (int p = 0; p < 3; p++) {\n"
"        int pad_s, pad_c;\n"
"        int write_start = write_ptr;\n"
"        put_bits(8, 0);\n"
"        #pragma unroll\n"
"        for (int level = 0; level < wavelet_depth; level++) {\n"
"            ivec2 band_size = slice_dim >> level;\n"
"            #pragma unroll\n"
"            for (int orientation = int(level > 0); orientation < 4; orientation++) {\n"
"                encode_subband(slice_coord, band_size, luts.quant[level][orientation],\n"
"                               orientation, p);\n"
"            }\n"
"        }\n"
"        flush_put_bits();\n"
"        int bytes_len = (write_ptr - write_start) * 4 - 1;\n"
"        if (p == 2) {\n"
"            int len_diff = slice_bytes_max - put_bytes_output();\n"
"            pad_s = align((bytes_len + len_diff), size_scaler)/size_scaler;\n"
"            pad_c = (pad_s*size_scaler) - bytes_len;\n"
"        } else {\n"
"            pad_s = align(bytes_len, size_scaler)/size_scaler;\n"
"            pad_c = (pad_s*size_scaler) - bytes_len;\n"
"        }\n"
"        /* Write the lower 8 bytes of write_start with pad_s */\n"
"        pb.data[write_start] &= ~0xFF;\n"
"        pb.data[write_start] |= pad_s & 0xFF;\n"
"        /* vc2-reference uses that padding that decodes to '0' coeffs */\n"
"        for (int i = 0; i < pad_c; i++) {\n"
"            pb.data[write_ptr++] = uint8_t(0xFF);\n"
"        }\n"
"        // memset(put_bits_ptr(pb), 0xFF, pad_c);\n"
"        skip_put_bytes(pad_c);\n"
"    }\n"
"}\n"
"\n"
"void main() {\n"
"    /* Step 1. TODO: Figure out appropriate quant index for optimal slice size */\n"
"    int slice_bytes_max = (1280 * 720 * 3 / 2) / (num_slices.x * num_slices.y);\n"
"\n"
"    /* Step 2. Quantize and encode */\n"
"    encode_hq_slice(slice_bytes_max);\n"
"}\n";
