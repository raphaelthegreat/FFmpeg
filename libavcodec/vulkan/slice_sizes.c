// Generated from libavcodec/vulkan/slice_sizes.comp
const char *ff_source_slice_sizes_comp =
"#version 450 core\n"
"#extension GL_EXT_shader_explicit_arithmetic_types : require\n"
"\n"
"#define SLICE_WIDTH 32\n"
"#define SLICE_HEIGHT 16\n"
"\n"
"layout(local_size_x = SLICE_WIDTH, local_size_y = SLICE_HEIGHT, local_size_z = 1) in;\n"
"\n"
"#define DIRAC_MAX_QUANT_INDEX 116\n"
"#define MAX_DWT_LEVELS 5\n"
"\n"
"struct SliceArgs {\n"
"    int cache[DIRAC_MAX_QUANT_INDEX];\n"
"    int x;\n"
"    int y;\n"
"    int quant_idx;\n"
"    int bits_ceil;\n"
"    int bits_floor;\n"
"    int bytes;\n"
"};\n"
"\n"
"layout(std430, buffer_reference) buffer SliceArgBuf {\n"
"    SliceArgs args[];\n"
"};\n"
"\n"
"layout(push_constant, std140) uniform ComputeInfo {\n"
"    int wavelet_depth;\n"
"    ivec2 slice_dim;\n"
"    int quant_idx;\n"
"    int size_scaler;\n"
"    int prefix_bytes;\n"
"    ivec2 num_slices;\n"
"    DwtCoef p[3];\n"
"    BitBuf pb;\n"
"    SliceArgBuf slices;\n"
"};\n"
"\n"
"int count_vc2_ue_uint(int val) {\n"
"    int topbit = 1, maxval = 1;\n"
"    if (!val++)\n"
"        return 1;\n"
"    while (val > maxval) {\n"
"        topbit <<= 1;\n"
"        maxval <<= 1;\n"
"        maxval |=  1;\n"
"    }\n"
"    return log2(topbit)*2 + 1;\n"
"}\n"
"\n"
"int ffalign(int x, int a) {\n"
"    return (x + a - 1) & ~(a - 1);\n"
"}\n"
"\n"
"int get_level() {\n"
"    ivec2 slice_coord = ivec2(gl_LocalInvocationID.xy);\n"
"    ivec2 image_dim = ivec2(SLICE_WIDTH, SLICE_HEIGHT) * num_slices;\n"
"    #pragma unroll\n"
"    for (int level = 0; level < 5; level++) {\n"
"        /* wavelet_depth = how many times to divide by 2 to get band width of level 0 */\n"
"        int div = 2 * (wavelet_depth - level);\n"
"        if (all(lessThan(slice_coord, image_dim / div))) {\n"
"            return level;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"int count_hq_slice(int quant_idx) {\n"
"    shared int bits = 0;\n"
"    const int slice_idx = gl_WorkGroupID.y * gl_NumWorkgroups.x + gl_WorkGroupID.x;\n"
"\n"
"    SliceArgs slice = slices.args[slice_idx];\n"
"    if (slice.cache[quant_idx])\n"
"        return slice.cache[quant_idx];\n"
"\n"
"    /* Initialize bits array */\n"
"    bits = 8 * (prefix_bytes + 1);\n"
"\n"
"    const int level = get_level();\n"
"    const int b_width = SLICE_WIDTH >> level;\n"
"    const int b_height = SLICE_HEIGHT >> level;\n"
"    const int s_x = gl_WorkGroupID.x;\n"
"    const int s_y = gl_WorkGroupID.y;\n"
"\n"
"    const int q_idx = quant[level][orientation];\n"
"    const int q_s = av_log2(ff_dirac_qscale_tab[q_idx]) + 32;\n"
"\n"
"    for (int p = 0; p < 3; p++) {\n"
"        /* This is executed once for each plane */\n"
"        if (gl_LocalInvocationIndex == 0) {\n"
"            atomicAdd(bits, 8);\n"
"        }\n"
"        barrier();\n"
"\n"
"        /* Perform quantization and calculate size with exp-Golomb coding */\n"
"        const int c_abs = (abs(buf[x] / q_idx) >> q_s;\n"
"        atomicAdd(bits, count_vc2_ue_uint(c_abs) + int(c_abs != 0));\n"
"\n"
"        /* This is executed once for each plane */\n"
"        if (gl_LocalInvocationIndex == 0) {\n"
"            atomicAdd(bits, ffalign(bits, 8) - bits);\n"
"            const int bytes_len = (bits >> 3) - 1;\n"
"            const int pad_s = ffalign(bytes_len, size_scaler) / size_scaler;\n"
"            const int pad_c = (pad_s * size_scaler) - bytes_len;\n"
"            atomicAdd(bits, pad_c * 8);\n"
"        }\n"
"        barrier();\n"
"    }\n"
"\n"
"    slices.args[slice_idx].cache[quant_idx] = bits;\n"
"    return bits;\n"
"}\n"
"\n"
"int av_rescale(int a, int b, int c) {\n"
"    // TODO: This won't overflow, right?\n"
"    const int r = c / 2;\n"
"    return (a * b + r) / c;\n"
"}\n"
"\n"
"int ssize_round(int b, int size_scaler, int prefix_bytes) {\n"
"    return ffalign(b, size_scaler) + 4 + prefix_bytes;\n"
"}\n"
"\n"
"void main() {\n"
"    /* Use the first invocation of the workgroup to compute the min/max slice sizes. */\n"
"    shared int bits_ceil = 0;\n"
"    shared int bits_floor = 0;\n"
"    if (gl_LocalInvocationIndex == 0) {\n"
"        const bool bitexact = true;\n"
"        const int aux_data_size = bitexact ? 5 : 13;\n"
"        const int header_size = 100 + aux_data_size;\n"
"        const int bit_rate = 600000000;\n"
"        const int interlaced = 0;\n"
"        const int time_base_num = 1;\n"
"        const int time_base_den = 30;\n"
"        const int r_bitrate = bit_rate >> interlaced;\n"
"\n"
"        const int frame_max_bytes = (av_rescale(r_bitrate, time_base_num, time_base_den) >> 3) - header_size;\n"
"        const int slice_ceil = av_rescale(frame_max_bytes, 1, gl_NumWorkgroups.x * gl_NumWorkgroups.y);\n"
"        int slice_max_bytes = slice_ceil;\n"
"\n"
"        /* Find an appropriate size scaler */\n"
"        int size_scaler = 2;\n"
"        int sig_size = 256;\n"
"        while (sig_size > 255) {\n"
"            int r_size = ssize_round(slice_max_bytes, size_scaler, prefix_bytes);\n"
"            if (r_size > slice_ceil) {\n"
"                slice_max_bytes -= r_size - slice_ceil;\n"
"                r_size = ssize_round(slice_max_bytes, size_scaler, prefix_bytes);\n"
"            }\n"
"            sig_size = r_size / size_scaler; /* Signalled slize size */\n"
"            size_scaler <<= 1;\n"
"        }\n"
"\n"
"        const float tolerance = 5.f;\n"
"        const int slice_min_bytes = slice_max_bytes - slice_max_bytes*(tolerance/100.0f);\n"
"        bits_ceil = slice_max_bytes << 3;\n"
"        bits_floor = slice_min_bytes << 3;\n"
"    }\n"
"    barrier();\n"
"\n"
"    /* Calculate the size of the slice */\n"
"    const int q_ceil = DIRAC_MAX_QUANT_INDEX;\n"
"    const int top = bits_ceil;\n"
"    const int bottom = bits_floor;\n"
"    int quant_buf[2] = int[2](-1, -1);\n"
"    int quant = quant_idx;\n"
"    int step = 1;\n"
"    int bits_last = 0;\n"
"    int bits = count_hq_slice(quant);\n"
"    while ((bits > top) || (bits < bottom)) {\n"
"        const int signed_step = bits > top ? +step : -step;\n"
"        quant  = clamp(quant + signed_step, 0, q_ceil-1);\n"
"        bits = count_hq_slice(quant);\n"
"        if (quant_buf[1] == quant) {\n"
"            quant = max(quant_buf[0], quant);\n"
"            bits  = quant == quant_buf[0] ? bits_last : bits;\n"
"            break;\n"
"        }\n"
"        step         = av_clip(step/2, 1, (q_ceil-1)/2);\n"
"        quant_buf[1] = quant_buf[0];\n"
"        quant_buf[0] = quant;\n"
"        bits_last    = bits;\n"
"    }\n"
"    slice_dat->quant_idx = av_clip(quant, 0, q_ceil-1);\n"
"    slice_dat->bytes = SSIZE_ROUND(bits >> 3);\n"
"}\n";
