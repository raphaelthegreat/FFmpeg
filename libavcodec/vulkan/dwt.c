// Generated from libavcodec/vulkan/dwt.comp
const char *ff_source_dwt_comp =
"#version 450 core\n"
"#extension GL_EXT_buffer_reference : require\n"
"\n"
"#define SLICE_WIDTH 32\n"
"#define SLICE_HEIGHT 16\n"
"\n"
"layout(local_size_x = SLICE_WIDTH, local_size_y = SLICE_HEIGHT, local_size_z = 1) in;\n"
"\n"
"layout (set = 0, binding = 0, r32ui) uniform uimage2D planes[3];\n"
"\n"
"layout(std430, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {\n"
"    uint coef_buf[];\n"
"};\n"
"\n"
"layout(push_constant, std140) uniform ComputeInfo {\n"
"    int wavelet_depth;\n"
"    int s;\n"
"    DwtCoef p[3];\n"
"};\n"
"\n"
"void dwt_haar(ivec2 dst_size, int plane_idx) {\n"
"    int stride = imageSize(planes[plane_idx]).x;\n"
"    ivec2 synth_size = dst_size << 1;\n"
"    ivec2 slice_base = ivec2(gl_WorkGroupID.xy) * ivec2(SLICE_WIDTH, SLICE_HEIGHT);\n"
"    ivec2 coord_in_slice = ivec2(gl_LocalInvocationID.xy);\n"
"\n"
"    /* For horizontal synth pass, each invocation handles a horizontal pair of pixels */\n"
"    ivec2 coord_in_slice_x = ivec2(gl_LocalInvocationID.xy) << ivec2(1, 0);\n"
"    if (all(lessThan(coord_in_slice_x, synth_size))) {\n"
"        ivec2 coord_x = slice_base + coord_in_slice_x;\n"
"        uint a = imageLoad(planes[plane_idx], coord_x).x;\n"
"        uint b = imageLoad(planes[plane_idx], coord_x + ivec2(1, 0)).x;\n"
"        uint dst_b = (b - a) * (1 << s);\n"
"        uint dst_a = a * (1 << s) + ((dst_b + 1) >> 1);\n"
"        p[plane_idx].coef_buf[coord_x.y * stride + coord_x.x] = dst_a;\n"
"        p[plane_idx].coef_buf[coord_x.y * stride + coord_x.x + 1] = dst_b;\n"
"    }\n"
"    memoryBarrier();\n"
"\n"
"    /* For vertical synth pass, each invocation handles a vertical pair of pixels */\n"
"    ivec2 coord_in_slice_y = ivec2(gl_LocalInvocationID.xy) << ivec2(0, 1);\n"
"    if (all(lessThan(coord_in_slice_y, synth_size))) {\n"
"        ivec2 coord_y = slice_base + coord_in_slice_y;\n"
"        uint a = imageLoad(planes[plane_idx], coord_y).x;\n"
"        uint b = imageLoad(planes[plane_idx], coord_y + ivec2(0, 1)).x;\n"
"        uint dst_b = b - a;\n"
"        uint dst_a = a + ((dst_b + 1) >> 1);\n"
"        p[plane_idx].coef_buf[coord_y.y * stride + coord_y.x] = dst_a;\n"
"        p[plane_idx].coef_buf[(coord_y.y + 1) * stride + coord_y.x + 1] = dst_b;\n"
"    }\n"
"    memoryBarrier();\n"
"\n"
"    /* Finally deinterleave result. Here each invocation is responsible for a single pixel */\n"
"    if (all(lessThan(coord_in_slice, synth_size))) {\n"
"        ivec2 coord = ivec2(gl_GlobalInvocationID.xy);\n"
"        ivec2 subband = coord_in_slice & int(1);\n"
"        ivec2 new_coord_in_slice = subband * dst_size + (coord_in_slice >> 1);\n"
"        ivec2 new_coord = slice_base + new_coord_in_slice;\n"
"        uint texel = p[plane_idx].coef_buf[coord.y * stride + coord.x];\n"
"        barrier();\n"
"        p[plane_idx].coef_buf[new_coord.y * stride + new_coord.x] = texel;\n"
"    }\n"
"}\n"
"\n"
"void main() {\n"
"    #pragma unroll\n"
"    for (int p = 0; p < 3; p++) {\n"
"        #pragma unroll\n"
"        for (int l = 1; l <= wavelet_depth; l++) {\n"
"            ivec2 dst_size = ivec2(SLICE_WIDTH, SLICE_HEIGHT) >> l;\n"
"            dwt_haar(dst_size, p);\n"
"        }\n"
"    }\n"
"}\n"
;
