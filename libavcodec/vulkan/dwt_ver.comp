#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_debug_printf : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(scalar, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {
    int coef_buf[];
};

struct Plane {
    ivec2 dim;
    int coef_stride;
    int pad;
};

#define VC2_TRANSFORM_HAAR (3)
#define VC2_TRANSFORM_HAAR_S (4)
#define VC2_TRANSFORM_5_3 (1)

layout(push_constant, scalar) uniform ComputeInfo {
    int s;
    int diff_offset;
    int level;
    int wavelet_type;
    Plane planes[3];
    DwtCoef dst_buf[3];
    DwtCoef src_buf[3];
};

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    /* For vertical synth pass, each invocation handles a vertical pair of pixels */
    uint plane_idx = gl_GlobalInvocationID.z;
    ivec2 coord_y = coord << ivec2(0, 1);
    ivec2 work_area = planes[plane_idx].dim >> level;
    ivec2 dwt_area = work_area >> 1;
    if (wavelet_type == VC2_TRANSFORM_HAAR || wavelet_type == VC2_TRANSFORM_HAAR_S) {
        if (any(greaterThanEqual(coord_y, work_area))) {
            return;
        }
        int stride = planes[plane_idx].coef_stride;
        int a = dst_buf[plane_idx].coef_buf[coord_y.y * stride + coord_y.x];
        int b = dst_buf[plane_idx].coef_buf[(coord_y.y + 1) * stride + coord_y.x];
        int dst_b = b - a;
        int dst_a = a + ((dst_b + 1) >> 1);
        dst_buf[plane_idx].coef_buf[coord_y.y * stride + coord_y.x] = dst_a;
        dst_buf[plane_idx].coef_buf[(coord_y.y + 1) * stride + coord_y.x] = dst_b;
    } else {
        if (any(greaterThanEqual(coord, work_area))) {
            return;
        }
        int stride = planes[plane_idx].coef_stride;
        int index = stride * coord.y + coord.x;
        // Lifting stage 2
        if (coord.y > 0 && coord.y < work_area.y - 1 && (((coord.y - 1) & 1) == 0)) {
            int a = dst_buf[plane_idx].coef_buf[index];
            int b = dst_buf[plane_idx].coef_buf[stride * (coord.y - 1) + coord.x];
            int c = dst_buf[plane_idx].coef_buf[stride * (coord.y + 1) + coord.x];
            a -= (b + c + 1) >> 1;
            dst_buf[plane_idx].coef_buf[index] = a;
        } else if (coord.y == work_area.y - 1) {
            int a = dst_buf[plane_idx].coef_buf[index];
            int b = dst_buf[plane_idx].coef_buf[stride * (coord.y - 1) + coord.x];
            a -= (2 * b + 1) >> 1;
            dst_buf[plane_idx].coef_buf[index] = a;
        }

        // Lifting stage 1
        if (coord.y == 0) {
            int a = dst_buf[plane_idx].coef_buf[index];
            int b = dst_buf[plane_idx].coef_buf[stride * (coord.y + 1) + coord.x];
            a += (2 * b + 2) >> 2;
            dst_buf[plane_idx].coef_buf[index] = a;
        } else if ((coord.y & 1) == 0) {
            int a = dst_buf[plane_idx].coef_buf[index];
            int b = dst_buf[plane_idx].coef_buf[stride * (coord.y - 1) + coord.x];
            int c = dst_buf[plane_idx].coef_buf[stride * (coord.y + 1) + coord.x];
            a += (c + b + 2) >> 2;
            dst_buf[plane_idx].coef_buf[index] = a;
        }
    }
}
