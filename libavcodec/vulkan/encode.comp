#version 450 core
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

// TODO: Process pixels in parallel
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define MAX_DWT_LEVELS (5)

layout(std430, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {
    int coef_buf[];
};
layout(std430, buffer_reference, buffer_reference_align = 1) buffer BitBuf {
    uint8_t data[];
};

layout(push_constant, std140) uniform ComputeInfo {
    int wavelet_depth;
    ivec2 slice_dim;
    int quant_idx;
    int size_scaler;
    int prefix_bytes;
    ivec2 num_slices;
    DwtCoef p[3];
    BitBuf pb;
};

int encode_subband(ivec2 slice_coord, ivec2 band_size, int quant, int o, int plane, int write_index) {
    int left = band_size.x * (slice_coord.x+0) / num_slices.x;
    int right = band_size.x * (slice_coord.x+1) / num_slices.x;
    int top = band_size.y * (slice_coord.y+0) / num_slices.y;
    int bottom = band_size.y * (slice_coord.y+1) / num_slices.y;

    int stride = slice_dim.x * num_slices.x;
    int band_ptr = int(o > 1) * band_size.y * stride + (o & 1) * band_size.x;
    int start = band_ptr + top * stride;
    const int q_s = int(log2(ff_dirac_qscale_tab[quant])) + 32;

    for (int y = top; y < bottom; y++) {
        for (int x = left; x < right; x++) {
            int coef = p[plane].coef_buf[band_ptr + x];
            uint c_abs = uint((abs(coef) / quant) >> q_s);
            for (int i = 0; i < 4; i++) {
                pb.data[write_index++] = uint8_t((c_abs >> (i * 8)) & 0xFF);
            }
            //if (c_abs != 0)
            //    put_bits(pb, 1, coef < 0);
        }
        band_ptr += stride;
    }

    return write_index;
}

int align(int x, int a) {
    return (x+a-1) & ~(a-1);
}

void encode_hq_slice(int slice_bytes_max) {
    ivec2 slice_coord = ivec2(gl_GlobalInvocationID.xy);
    int slice_index = slice_coord.y * slice_dim.x + slice_coord.x;
    int write_ptr = slice_bytes_max * slice_index;
    int bit_ptr = 0;

    /* The reference decoder ignores it, and its typical length is 0 */
    for (int i = 0; i < prefix_bytes; i++) {
        pb.data[write_ptr + i] = uint8_t(0);
    }
    write_ptr += prefix_bytes;

    /* Write quant index for this slice */
    for (int i = 0; i < 4; i++) {
        pb.data[write_ptr++] = uint8_t((quant_idx >> (i * 8)) & 0xFF);
    }
    //pb.data[write_ptr++] = quant_idx;

    /* Luma + 2 Chroma planes */
    #pragma unroll
    for (int p = 0; p < 3; p++) {
        int pad_s, pad_c;
        int bytes_start = write_ptr;
        pb.data[write_ptr++] = uint8_t(0);
        #pragma unroll
        for (int level = 0; level < wavelet_depth; level++) {
            ivec2 band_size = slice_dim >> level;
            #pragma unroll
            for (int orientation = int(level > 0); orientation < 4; orientation++) {
                write_ptr = encode_subband(slice_coord, band_size, quant[level][orientation],
                                           orientation, p, write_ptr);
            }
        }
        //flush_put_bits(pb);
        int bytes_len = /*put_bytes_output(pb)*/write_ptr - bytes_start - 1;
        if (p == 2) {
            int len_diff = slice_bytes_max - /*put_bytes_output(pb)*/write_ptr;
            pad_s = align((bytes_len + len_diff), size_scaler)/size_scaler;
            pad_c = (pad_s*size_scaler) - bytes_len;
        } else {
            pad_s = align(bytes_len, size_scaler)/size_scaler;
            pad_c = (pad_s*size_scaler) - bytes_len;
        }
        pb.data[bytes_start] = uint8_t(pad_s);
        /* vc2-reference uses that padding that decodes to '0' coeffs */
        for (int i = 0; i < pad_c; i++) {
            pb.data[write_ptr++] = uint8_t(0xFF);
        }
        // memset(put_bits_ptr(pb), 0xFF, pad_c);
        // skip_put_bytes(pb, pad_c);
    }
}

void main() {
    /* Step 1. TODO: Figure out appropriate quant index for optimal slice size */
    int slice_bytes_max = (1280 * 720 * 3 / 2) / (num_slices.x * num_slices.y);

    /* Step 2. Quantize and encode */
    encode_hq_slice(slice_bytes_max);
}