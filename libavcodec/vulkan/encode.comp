#extension GL_EXT_shader_explicit_arithmetic_types : require

// TODO: Process pixels in parallel
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define MAX_DWT_LEVELS (5)

layout(std430, buffer_reference, buffer_reference_align = 4) buffer DwtCoef {
    int coef_buf[];
};
layout(std430, buffer_reference, buffer_reference_align = 1) buffer BitBuf {
    uint data[];
};
layout(std430, buffer_reference, buffer_reference_align = 4) buffer QuantLuts {
    int quant[5][4];
    int ff_dirac_qscale_tab[116];
};

layout(push_constant, std430) uniform ComputeInfo {
    DwtCoef p[4];
    BitBuf pb;
    QuantLuts luts;
    ivec2 num_slices;
    ivec2 slice_dim;
    int wavelet_depth;
    int quant_idx;
    int size_scaler;
    int prefix_bytes;
};

uint bit_buf = 0;
uint bit_left = 32;
int write_ptr = 0;

void put_bits(int n, int value) {
    if (n < bit_left) {
        bit_buf = (bit_buf << n) | value;
        bit_left -= n;
    } else {
        bit_buf <<= bit_left;
        bit_buf |= value >> (n - bit_left);
        pb.data[write_ptr++] = bit_buf;
        bit_left += 32 - n;
        bit_buf = value;
    }
}

void put_vc2_ue_uint(int val) {
    int pbits = 0, topbit = 1, maxval = 1;
    if (val++ == 0) {
        put_bits(1, 1);
        return;
    }

    while (val > maxval) {
        topbit <<= 1;
        maxval <<= 1;
        maxval |=  1;
    }

    int bits = int(log2(topbit));
    for (int i = 0; i < bits; i++) {
        topbit >>= 1;
        pbits <<= 2;
        if ((val & topbit) != 0) {
            pbits |= 0x1;
        }
    }

    put_bits(bits * 2 + 1, (pbits << 1) | 1);
}

void flush_put_bits() {
    pb.data[write_ptr++] = bit_buf;
    bit_buf = 0;
}

int put_bytes_output() {
    return write_ptr * 4;
}

void skip_put_bytes(int n) {
    write_ptr += (n >> 2);
    bit_left = (n % 4) * 8;
}

void encode_subband(ivec2 slice_coord, ivec2 band_size, int quant, int o, int plane) {
    int left = band_size.x * (slice_coord.x+0) / num_slices.x;
    int right = band_size.x * (slice_coord.x+1) / num_slices.x;
    int top = band_size.y * (slice_coord.y+0) / num_slices.y;
    int bottom = band_size.y * (slice_coord.y+1) / num_slices.y;

    int stride = slice_dim.x * num_slices.x;
    int band_ptr = int(o > 1) * band_size.y * stride + (o & 1) * band_size.x;
    int start = band_ptr + top * stride;
    const int q_s = int(log2(luts.ff_dirac_qscale_tab[quant])) + 32;

    for (int y = top; y < bottom; y++) {
        for (int x = left; x < right; x++) {
            int coef = p[plane].coef_buf[band_ptr + x];
            int c_abs = int((abs(coef) / quant) >> q_s);
            put_vc2_ue_uint(c_abs);
            if (c_abs != 0)
                put_bits(1, int(coef < 0));
        }
        band_ptr += stride;
    }
}

int align(int x, int a) {
    return (x+a-1) & ~(a-1);
}

void encode_hq_slice(int slice_bytes_max) {
    ivec2 slice_coord = ivec2(gl_GlobalInvocationID.xy);
    int slice_index = slice_coord.y * slice_dim.x + slice_coord.x;
    write_ptr = slice_bytes_max * slice_index;

    /* Write quant index for this slice */
    put_bits(8, quant_idx);

    /* Luma + 2 Chroma planes */
    #pragma unroll
    for (int p = 0; p < 3; p++) {
        int pad_s, pad_c;
        int write_start = write_ptr;
        put_bits(8, 0);
        #pragma unroll
        for (int level = 0; level < wavelet_depth; level++) {
            ivec2 band_size = slice_dim >> level;
            #pragma unroll
            for (int orientation = int(level > 0); orientation < 4; orientation++) {
                encode_subband(slice_coord, band_size, luts.quant[level][orientation],
                               orientation, p);
            }
        }
        flush_put_bits();
        int bytes_len = (write_ptr - write_start) * 4 - 1;
        if (p == 2) {
            int len_diff = slice_bytes_max - put_bytes_output();
            pad_s = align((bytes_len + len_diff), size_scaler)/size_scaler;
            pad_c = (pad_s*size_scaler) - bytes_len;
        } else {
            pad_s = align(bytes_len, size_scaler)/size_scaler;
            pad_c = (pad_s*size_scaler) - bytes_len;
        }
        /* Write the lower 8 bytes of write_start with pad_s */
        pb.data[write_start] &= ~0xFF;
        pb.data[write_start] |= pad_s & 0xFF;
        /* vc2-reference uses that padding that decodes to '0' coeffs */
        for (int i = 0; i < pad_c; i++) {
            pb.data[write_ptr++] = uint8_t(0xFF);
        }
        // memset(put_bits_ptr(pb), 0xFF, pad_c);
        skip_put_bytes(pad_c);
    }
}

void main() {
    /* Step 1. TODO: Figure out appropriate quant index for optimal slice size */
    int slice_bytes_max = (1280 * 720 * 3 / 2) / (num_slices.x * num_slices.y);

    /* Step 2. Quantize and encode */
    //encode_hq_slice(slice_bytes_max);
}